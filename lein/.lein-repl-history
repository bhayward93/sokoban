(trace-vars format-state)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef :true)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars A*search)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(trace-vars format-state)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(trace-vars apply-all)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(format-state {:state world-state :cost 0})
(trace-vars list)
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars A*search)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars A*search)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(trace-vars format-state)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(trace-vars format-state)
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars clojure.lang.Util.compare)
(trace-vars compare)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(trace-vars compare)
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars compare)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars disj)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(trace-vars format-state)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(trace-vars format-state)
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars disj)
(trace-vars format-state)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(untrace-vars disj)
(trace-vars map)
(untrace-vars map)
(trace-vars apply-all)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit4
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exir
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars A*search)
(trace-vars format-state))
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} '((at '(4 8) w0)) format-state :state :cost :undef true)
(contains? world-state '(at '(3 8) w0))
(contains? world-state '(at '(3 8) w1))
(A*search {:state world-state :cost 0} (fn [x] (contains? x (at '(4 8) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(4 8) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(4 8) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(use '(clojure.tools.trace))
(use 'clojure.tools.trace)
(trace-vars apply-all)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(untrace-vars apply-all)
(trace-vars format-state)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(untrace-vars format-state
)
(trace-vars map)
(untrace-vars map)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exir
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
world-state
target-state
clear
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 8) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 8) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
exit
(intersection world-state ((on (quote (6 1) none)))
)
(intersection world-state ('(on (quote (6 1) none)))
)
(intersection world-state ('(on ' (6 1) none)))
(intersection world-state ((on '(6 1) none)))
(intersection world-state (('on '(6 1) none)))
(intersection world-state (('on '(6 1) 'none)))
world-state
(intersection world-state #{(on '(4 2) none)}))
(intersection world-state #{'(on '(4 2) none)}))
(intersection world-state #{'(on '(4 2) none)})
(intersection world-state #{'(on '(4 2) none) '(on '(7 6) none)})
exit
xit
exit
(:range (:move test-ops))
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars mlet)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(trace-var* mlet)
(trace-vars intersection)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(eval ((2 '((+ 2 2) 3)
)
0
)
(eval ((2 '((+ 2 2) 3))))
(eval (+ 2 3))
(eval (2 (+ 2 3)))
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
eval 1
(eval 1)
exit
(mout (eval 1))
ecit
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exitg
exit
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(trace-vars get-locality)
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(mout bob)
exit
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(get-locality '(2 '(5 6)) (:range (:move test-ops)) world-state)
(intersection world-state (?_ '(5 2))
)
(intersection world-state (mout (?_ '(5 2)))
)
(intersection world-state (mout (?_ '(5 2))))
exit
(get-locality '(5 6) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 6) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 6) (:range (:move test-ops)) world-state)
(A*search {:state world-state :world target-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-all)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(trace-vars astar-apply-op)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(seq (bob((
))))
(seq (bob))
(seq #{bob nob}))
(seq #{bob nob})
(seq #{'bob 'nob})
exit
(alt-lmg {:state world-state :world-state target-state :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(trace-vars get-locality))
(trace-vars get-locality)
(alt-lmg {:state world-state :world-state target-state :cost 0})
exit
(alt-lmg {:state world-state :world-state target-state :cost 0})
exit
(get-locality (2 '(5 6)) (:range (:move test-ops)) world-state)
(get-locality (2 '(5 6)) (:range (:move lmg-ops-test)) world-state)
(get-locality '(5 6) (:range (:move lmg-ops-test)) world-state)
(get-locality '(5 6) (:range (:push-box lmg-ops-test)) world-state)
exit
(alt-lmg {:state world-state :world-state target-state :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(alt-lmg {:state world-state :world-state target-state :cost 0})
target-state
(alt-lmg {:state world-state :world target-state :cost 0})
clear
(alt-lmg {:state world-state :world target-state :cost 0})
(astar-apply-op (:when (:move lmg-ops-test)) world-state target-state)
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
(alt-lmg {:state world-state :world target-state :cost 0})
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
(:when (:move lmg-ops-test))
(:when (:when (:move lmg-ops-test)))
exit
(alt-lmg {:state world-state :world target-state :cost 0})
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(alt-lmg {:state current-state :world world :cost 0})
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
world
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(trace-vars intersection)
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
exit
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(trace-vars intersection)
(alt-lmg {:state current-state :world world :cost 0})
(trace-vars set)
(alt-lmg {:state current-state :world world :cost 0})
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
exit
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(alt-lmg {:state current-state :world world :cost 0})
exit
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
exit
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(astar-apply-op (:move lmg-ops-test) world current-statee)
(astar-apply-op (:move lmg-ops-test) world current-state)
exit
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(alt-lmg {:state current-state :world world :cost 0})
(trace-vars set)
(alt-lmg {:state current-state :world world :cost 0})
(trace-vars union)
(untrace-vars set)
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(trace-vars intersection)
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-all)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(trace-vars astar-apply-op)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(trace-vars get-locality)
(trace-vars intersection)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(alt-lmg {:state current-state :world world :cost 0})
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
exit
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(trace-vars astar-apply-op)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(trace-vars get-locality)
(trace-vars intersection)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
wor
world
current-state
clear
current-state
(difference current-state ((at '(3 8)) w0))
(difference current-state (('at '(3 8)) 'w0))
current-state
(difference current-state '((at '(3 8)) w0))
(difference current-state ('(at '(3 8)) w0))
(difference current-state ('(at '(3 8) w0)))
(difference current-state '((at '(3 8) w0))
)
current-state
(def new-state (union '((at '(2 6) w0)) (difference current-state'((at '(3 8) w0)))))
current-state
(def new-state (union '((at '(2 6) w0)) (difference current-state'((at '(3 8) w0)))))
(def new-state (union (set '((at '(2 6) w0))) (difference current-state (set '((at '(3 8) w0))))))
new-state
(alt-lmg {:state current-state :world world :cost 0})
(alt-lmg {:state new-state :world world :cost 0})
exit
(def new-state (union (set '((at '(2 6) w0))) (difference current-state (set '((at '(3 8) w0))))))
(alt-lmg {:state new-state :world world :cost 0})
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
exit
exit4
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(5 8) b1))) alt-lmg :state :cost :undef true)
exit
