(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
exit
(trace-vars format-state)
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars disj)
(trace-vars format-state)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(untrace-vars disj)
(trace-vars map)
(untrace-vars map)
(trace-vars apply-all)
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit4
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exir
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
exit
(format-state {:state world-state :cost 0})
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars A*search)
(trace-vars format-state))
(A*search {:state world-state :cost 0} '(at '(4 8) w0) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} '((at '(4 8) w0)) format-state :state :cost :undef true)
(contains? world-state '(at '(3 8) w0))
(contains? world-state '(at '(3 8) w1))
(A*search {:state world-state :cost 0} (fn [x] (contains? x (at '(4 8) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(4 8) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(4 8) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(use '(clojure.tools.trace))
(use 'clojure.tools.trace)
(trace-vars apply-all)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(untrace-vars apply-all)
(trace-vars format-state)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(untrace-vars format-state
)
(trace-vars map)
(untrace-vars map)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exir
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
world-state
target-state
clear
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 8) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 8) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars apply-op)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) format-state :state :cost :undef true)
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
exit
(A*search {:state world-state :cost 0} (fn [x] (contains? x '(on '(5 6) b1))) format-state :state :cost :undef true)
exit
(intersection world-state ((on (quote (6 1) none)))
)
(intersection world-state ('(on (quote (6 1) none)))
)
(intersection world-state ('(on ' (6 1) none)))
(intersection world-state ((on '(6 1) none)))
(intersection world-state (('on '(6 1) none)))
(intersection world-state (('on '(6 1) 'none)))
world-state
(intersection world-state #{(on '(4 2) none)}))
(intersection world-state #{'(on '(4 2) none)}))
(intersection world-state #{'(on '(4 2) none)})
(intersection world-state #{'(on '(4 2) none) '(on '(7 6) none)})
exit
xit
exit
(:range (:move test-ops))
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars mlet)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(trace-var* mlet)
(trace-vars intersection)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(5 2) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 2) (:range (:move test-ops)) world-state)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(eval ((2 '((+ 2 2) 3)
)
0
)
(eval ((2 '((+ 2 2) 3))))
(eval (+ 2 3))
(eval (2 (+ 2 3)))
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
eval 1
(eval 1)
exit
(mout (eval 1))
ecit
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 (5 2)) (:range (:move test-ops)) world-state)
exitg
exit
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(trace-vars get-locality)
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(mout bob)
exit
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(use 'clojure.tools.trace)
(trace-vars intersection)
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
exit
(get-locality '(2 '(5 2)) (:range (:move test-ops)) world-state)
(get-locality '(2 '(5 6)) (:range (:move test-ops)) world-state)
(intersection world-state (?_ '(5 2))
)
(intersection world-state (mout (?_ '(5 2)))
)
(intersection world-state (mout (?_ '(5 2))))
exit
(get-locality '(5 6) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 6) (:range (:move test-ops)) world-state)
exit
(get-locality '(5 6) (:range (:move test-ops)) world-state)
(A*search {:state world-state :world target-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-all)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(trace-vars astar-apply-op)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(seq (bob((
))))
(seq (bob))
(seq #{bob nob}))
(seq #{bob nob})
(seq #{'bob 'nob})
exit
(alt-lmg {:state world-state :world-state target-state :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(alt-lmg {:state world-state :world-state target-state :cost 0})
(trace-vars get-locality))
(trace-vars get-locality)
(alt-lmg {:state world-state :world-state target-state :cost 0})
exit
(alt-lmg {:state world-state :world-state target-state :cost 0})
exit
(get-locality (2 '(5 6)) (:range (:move test-ops)) world-state)
(get-locality (2 '(5 6)) (:range (:move lmg-ops-test)) world-state)
(get-locality '(5 6) (:range (:move lmg-ops-test)) world-state)
(get-locality '(5 6) (:range (:push-box lmg-ops-test)) world-state)
exit
(alt-lmg {:state world-state :world-state target-state :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(alt-lmg {:state world-state :world-state target-state :cost 0})
target-state
(alt-lmg {:state world-state :world target-state :cost 0})
clear
(alt-lmg {:state world-state :world target-state :cost 0})
(astar-apply-op (:when (:move lmg-ops-test)) world-state target-state)
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
(alt-lmg {:state world-state :world target-state :cost 0})
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
(:when (:move lmg-ops-test))
(:when (:when (:move lmg-ops-test)))
exit
(alt-lmg {:state world-state :world target-state :cost 0})
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(alt-lmg {:state current-state :world world :cost 0})
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
world
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(trace-vars intersection)
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
exit
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(trace-vars intersection)
(alt-lmg {:state current-state :world world :cost 0})
(trace-vars set)
(alt-lmg {:state current-state :world world :cost 0})
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
exit
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(alt-lmg {:state current-state :world world :cost 0})
exit
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
exit
(astar-apply-op (:when (:push-box lmg-ops-test)) world-state target-state)
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(astar-apply-op (:move lmg-ops-test) world current-statee)
(astar-apply-op (:move lmg-ops-test) world current-state)
exit
(get-locality '(5 6) (:range (:move lmg-ops-test)) world)
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(alt-lmg {:state current-state :world world :cost 0})
(trace-vars set)
(alt-lmg {:state current-state :world world :cost 0})
(trace-vars union)
(untrace-vars set)
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(trace-vars astar-apply-all)
(trace-vars get-locality)
(trace-vars intersection)
(alt-lmg {:state current-state :world world :cost 0})
exit
(alt-lmg {:state current-state :world world :cost 0})
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-all)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(trace-vars astar-apply-op)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(trace-vars get-locality)
(trace-vars intersection)
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(alt-lmg {:state current-state :world world :cost 0})
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
exit
(A*search {:state world :world current-state :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(trace-vars astar-apply-op)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(trace-vars get-locality)
(trace-vars intersection)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
wor
world
current-state
clear
current-state
(difference current-state ((at '(3 8)) w0))
(difference current-state (('at '(3 8)) 'w0))
current-state
(difference current-state '((at '(3 8)) w0))
(difference current-state ('(at '(3 8)) w0))
(difference current-state ('(at '(3 8) w0)))
(difference current-state '((at '(3 8) w0))
)
current-state
(def new-state (union '((at '(2 6) w0)) (difference current-state'((at '(3 8) w0)))))
current-state
(def new-state (union '((at '(2 6) w0)) (difference current-state'((at '(3 8) w0)))))
(def new-state (union (set '((at '(2 6) w0))) (difference current-state (set '((at '(3 8) w0))))))
new-state
(alt-lmg {:state current-state :world world :cost 0})
(alt-lmg {:state new-state :world world :cost 0})
exit
(def new-state (union (set '((at '(2 6) w0))) (difference current-state (set '((at '(3 8) w0))))))
(alt-lmg {:state new-state :world world :cost 0})
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
exit
exit4
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(7 2) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(4 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(on '(5 8) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) b1))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) b1))) alt-lmg :state :cost :undef true)
(use 'clojure.tools.trace)
(trace-vars astar-apply-op)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) b1))) alt-lmg :state :cost :undef true)
(untrace-vars astar-apply-op)
(untrace-vars astar-apply-all)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) b1))) alt-lmg :state :cost :undef true)
(trace-vars astar-apply-all)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) b1))) alt-lmg :state :cost :undef true)
(untrace-vars astar-apply-all)
(trace-vars alt-lmg)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) b1))) alt-lmg :state :cost :undef true)
exit
(use 'clojure.tools.trace)
(trace-vars alt-lmg)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) b1))) alt-lmg :state :cost :undef true)
(untrace-vars alt-lmg)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
exit
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(2 6) w0))) alt-lmg :state :cost :undef true)
(A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) w0))) alt-lmg :state :cost :undef true)
clear
exit
(extract-result :cmd (A*search {:state current-state :world world :cost 0} (fn [x] (contains? x '(at '(5 6) w0))) alt-lmg :state :cost :undef true))
(collect-result :cmd #{:tom 1 :dick 2 :harry 4 :cmd 6}
)
(collect-result :cmd #{:tom 1 :dick 2 :harry 4 :cmd 6} ())
(collect-result :cmd #{:tom 1 :dick 2 :harry 4 :cmd 6} '())
(:cmd #{:tom 1 :dick 2 :harry 4 :cmd 6})
(:cmd {:tom 1 :dick 2 :harry 4 :cmd 6})
(:harry {:tom 1 :dick 2 :harry 4 :cmd 6})
(collect-result :cmd {:tom 1 :dick 2 :harry 4 :cmd 6} '())
(collect-result :cmd {:tom 1 :dick 2 :harry 4 :cmd 6} '{})
exit
(collect-result :cmd {:tom 1 :dick 2 :harry 4 :cmd 6} '{})
(collect-result :cmd {:tom 1 :dick 2 :harry 4 :cmd 6} ())
(concat '{} ( result))
(concat '{} (:cmd {:tom 1 :dick 2 :harry 4 :cmd 6}))
(concat '{} (:cmd {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (at (quote (3 8)) w0) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}, :world #{(2 (quote (7 1))) (2 (quote (4 1))) (2 (quote (5 1))) (2 (quote (8 8))) (2 (quote (2 2))) (2 (quote (2 5))) (2 (quote (1 1))) (2 (quote (7 8))) (2 (quote (9 1))) (2 (quote (2 1))) (2 (quote (4 6))) (2 (quote (4 7))) (2 (quote (2 4))) (2 (quote (2 6))) (2 (quote (3 7))) (2 (quote (6 6))) (2 (quote (3 2))) (2 (quote (5 3))) (1 (quote (7 5))) (2 (quote (5 4))) (2 (quote (2 3))) (2 (quote (6 1))) (2 (quote (4 8))) (2 (quote (5 5))) (2 (quote (8 6))) (1 (quote (3 6))) (2 (quote (8 4))) (2 (quote (9 2))) (2 (quote (8 7))) (2 (quote (5 8))) (2 (quote (1 2))) (2 (quote (7 6))) (2 (quote (8 5))) (2 (quote (6 2))) (1 (quote (7 7))) (2 (quote (5 6))) (2 (quote (5 2))) (2 (quote (4 2))) (2 (quote (7 4))) (2 (quote (7 2))) (2 (quote (8 2))) (2 (quote (3 8))) (2 (quote (5 7))) (2 (quote (8 1))) (2 (quote (3 1)))}, :cost 0}))
(concat '{} (:cmd {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (at (quote (3 7)) w0) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}, :world #{(2 (quote (7 1))) (2 (quote (4 1))) (2 (quote (5 1))) (2 (quote (8 8))) (2 (quote (2 2))) (2 (quote (2 5))) (2 (quote (1 1))) (2 (quote (7 8))) (2 (quote (9 1))) (2 (quote (2 1))) (2 (quote (4 6))) (2 (quote (4 7))) (2 (quote (2 4))) (2 (quote (2 6))) (2 (quote (3 7))) (2 (quote (6 6))) (2 (quote (3 2))) (2 (quote (5 3))) (1 (quote (7 5))) (2 (quote (5 4))) (2 (quote (2 3))) (2 (quote (6 1))) (2 (quote (4 8))) (2 (quote (5 5))) (2 (quote (8 6))) (1 (quote (3 6))) (2 (quote (8 4))) (2 (quote (9 2))) (2 (quote (8 7))) (2 (quote (5 8))) (2 (quote (1 2))) (2 (quote (7 6))) (2 (quote (8 5))) (2 (quote (6 2))) (1 (quote (7 7))) (2 (quote (5 6))) (2 (quote (5 2))) (2 (quote (4 2))) (2 (quote (7 4))) (2 (quote (7 2))) (2 (quote (8 2))) (2 (quote (3 8))) (2 (quote (5 7))) (2 (quote (8 1))) (2 (quote (3 1)))}, :cmd (move w0 (quote (3 7))), :txt (w0 moves to (quote (3 7))), :cost 2}))
(:cmd {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (at (quote (3 7)) w0) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}, :world #{(2 (quote (7 1))) (2 (quote (4 1))) (2 (quote (5 1))) (2 (quote (8 8))) (2 (quote (2 2))) (2 (quote (2 5))) (2 (quote (1 1))) (2 (quote (7 8))) (2 (quote (9 1))) (2 (quote (2 1))) (2 (quote (4 6))) (2 (quote (4 7))) (2 (quote (2 4))) (2 (quote (2 6))) (2 (quote (3 7))) (2 (quote (6 6))) (2 (quote (3 2))) (2 (quote (5 3))) (1 (quote (7 5))) (2 (quote (5 4))) (2 (quote (2 3))) (2 (quote (6 1))) (2 (quote (4 8))) (2 (quote (5 5))) (2 (quote (8 6))) (1 (quote (3 6))) (2 (quote (8 4))) (2 (quote (9 2))) (2 (quote (8 7))) (2 (quote (5 8))) (2 (quote (1 2))) (2 (quote (7 6))) (2 (quote (8 5))) (2 (quote (6 2))) (1 (quote (7 7))) (2 (quote (5 6))) (2 (quote (5 2))) (2 (quote (4 2))) (2 (quote (7 4))) (2 (quote (7 2))) (2 (quote (8 2))) (2 (quote (3 8))) (2 (quote (5 7))) (2 (quote (8 1))) (2 (quote (3 1)))}, :cmd (move w0 (quote (3 7))), :txt (w0 moves to (quote (3 7))), :cost 2})
(concat '{} (:cmd {:tom 1 :dick 2 :harry 4 :cmd 6}))
(:harry {:tom 1 :dick 2 :harry 4 :cmd 6})
(:state {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (at (quote (3 7)) w0) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}, :world #{(2 (quote (7 1))) (2 (quote (4 1))) (2 (quote (5 1))) (2 (quote (8 8))) (2 (quote (2 2))) (2 (quote (2 5))) (2 (quote (1 1))) (2 (quote (7 8))) (2 (quote (9 1))) (2 (quote (2 1))) (2 (quote (4 6))) (2 (quote (4 7))) (2 (quote (2 4))) (2 (quote (2 6))) (2 (quote (3 7))) (2 (quote (6 6))) (2 (quote (3 2))) (2 (quote (5 3))) (1 (quote (7 5))) (2 (quote (5 4))) (2 (quote (2 3))) (2 (quote (6 1))) (2 (quote (4 8))) (2 (quote (5 5))) (2 (quote (8 6))) (1 (quote (3 6))) (2 (quote (8 4))) (2 (quote (9 2))) (2 (quote (8 7))) (2 (quote (5 8))) (2 (quote (1 2))) (2 (quote (7 6))) (2 (quote (8 5))) (2 (quote (6 2))) (1 (quote (7 7))) (2 (quote (5 6))) (2 (quote (5 2))) (2 (quote (4 2))) (2 (quote (7 4))) (2 (quote (7 2))) (2 (quote (8 2))) (2 (quote (3 8))) (2 (quote (5 7))) (2 (quote (8 1))) (2 (quote (3 1)))}, :cmd (move w0 (quote (3 7))), :txt (w0 moves to (quote (3 7))), :cost 2})
current-state
(:state {:state current-state :world world :cost 0})
(:state {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (at (quote (3 7)) w0) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (unloaded (quote (5 8))) (unloaded (quote (2 5)))})
(:state {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (at (quote (3 7)) w0) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}})
(:state {:state current-state :world world :cost 0})
(:state {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (at (quote (3 8)) w0) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}})
current-state
(:state {:state current-state})
(:state {:state #{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (at (quote (3 8)) w0) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}})
(:state {:state '#{(on (quote (7 5)) b2) (unloaded (quote (6 2))) (on (quote (7 7)) b0) (on (quote (3 6)) b1) (at (quote (3 8)) w0) (unloaded (quote (5 8))) (unloaded (quote (2 5)))}})
exit
(-main)
initial-state
world
current-state
exit
